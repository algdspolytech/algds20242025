# H_[5030102/30001]_Литовченко_Дмитрий

### Вариант 10: AVLДерево.
- Реализуйте операции добавления, удаления и поиска для AVLдеревьев. 
- Сравните время работы операций с их аналогами в дереве бинарного поиска.

---
## Описание файлов

`avl_tree.h / avl_tree.cpp`
Содержат реализацию AVL дерева:
- Структура узла хранит ключ и высоту.
- Балансировка происходит после каждой вставки и удаления для поддержания высоты O(log n).
- Реализованы ротации.

`bst_tree.h / bst_tree.cpp`
Содержат реализацию обычного BST:
- Структура узла хранит только ключ и указатели на детей.
- Не выполняется балансировка, что может приводить к вырождению в список (O(n) высота).

---
## Описание тестов

### `InsertSearchDeleteEdgeCases`
- Вставка краевых значений.
- Проверка успешного поиска всех вставленных значений.
- Удаление всех значений и проверка их отсутствия.

### `PerformanceTest`
- Бенчмарк вставки и поиска для 100000 отсортированных ключей.
- Сравнение времени выполнения между AVL и BST.
- Демонстрирует ухудшение BST при вставке отсортированных данных (вырождение в список).

### `RandomizedInsertSearch`
- Вставка 10000 случайно перемешанных ключей.
- Случайные запросы поиска для проверки корректности работы деревьев с неупорядоченными данными.

### `DegenerateCase`
- Специальный тест на вырождение BST (вставка строго возрастающей последовательности).
- AVL остаётся сбалансированным, BST — превращается в линейный список.

### `RandomDeletions`
- После случайной вставки, ключи удаляются в рандомном порядке.
- Проверка, что после удаления ключи больше не находятся в деревьях.

### `DuplicateInsertions`
- Вставка дубликатов одного и того же ключа.
- Проверка корректного поведения при работе с одинаковыми элементами.
---
## Плюсы и минусы AVL и BST

### BST 

**Плюсы:**
- Простая реализация.
- Быстрее AVL на небольших объемах данных.
- Нет затрат на балансировку при вставке и удалении.

**Минусы:**
- Может вырождаться в линейный список при неудачном порядке вставок.
- Худший случай для поиска, вставки и удаления — O(n).

---
### AVL Tree

**Плюсы:**
- Гарантированная высота O(log n) в любом случае.
- Быстрый поиск в худшем случае.
- Хорошо подходит для поиска в больших наборах данных.

**Минусы:**
- Сложнее реализация (ротации, пересчет высот).
- Более медленная вставка и удаление за счет постоянной балансировки.
- Немного больше памяти на хранение высоты узлов.

---
## Вывод

- Для задач с большим количеством **поисковых запросов** — предпочтительнее **AVL**.
- Если структура данных будет часто изменяться (много вставок/удалений) и данные приходят случайно — **BST** может быть проще и быстрее.
- Если данные заранее отсортированы или почти отсортированы — **BST** может деградировать в список, поэтому предпочтительнее **AVL**.
